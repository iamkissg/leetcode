# 队列与栈

## 队列

- 特点: 先进先出, FIFO
- 用`双指针`实现循环队列, 判满的条件: `(tail+1)%qsize==head%qsize`
- `按顺序处理元素`时, 可以考虑使用队列
- 广度优先遍历, 使用队列来保存节点, 适合发现最短路径, 用一个`visited`集合记录已经访问过的节点

## 栈

- 特点: 后进先出, LIFO
- 用`双栈`的思路来实现`最小栈`, 一个用作常规栈, 一个用作最小栈, 即栈顶元素总是当前最小的, 通过维护最小栈, 可以在常数时间内取得当前栈的最小值.
- 深度优先遍历, 使用栈来保存节点, 带`回溯`效果, 适合用于发现是否存在路径, 对于图, 同样可以维护一个`visited`集合.
- 一般用`递归`实现 DFS, 使用调用栈, 清晰明了; 否则的话, 需要自己手动维护一个栈

## 数组

- 数组的特点是, 占用连续内存空间, 存储相同类型的元素. 因为前两个特点, 支持通过索引的寻址, 支持 O(1) 随机访问元素
- 动态数组, 即 Cpp 中的`vector`, Java 的`ArrayList`等, 特点是**大小是可变的**.

## 二维数组

- 在一些语言中, 多位数组实际上内部是作为一维数组实现的, 也就是`A[i][j]=A[i*n_col+j]`; Java 中二维数组实际上是包含多个元素的一维数组

## 字符串

- 字符串实际上是`unicode 字符`数组
- Python 中, `str`是不可变的; Cpp 中字符串是可变的; Java 中, 字符串是不可变的
    - 在 Java 中，由于字符串是不可变的，因此在连接时首先为新字符串分配足够的空间，复制旧字符串中的内容并附加到新字符串, 运算的时间复杂度是`O(n^2)`.
    - 此时若希望字符串是可变的, 可以将其转化为字符数组 (Python 也存在类情况, 需用列表来解决)
    - Java 可以用`StringBuilder`
- `==` 比较两个字符串的值 (对于语言不支持运算符重载的, 则无法使用`==`来比较字符串)

## 双指针

- 使用双指针的经典场景之一: `从两端向中间迭代数组`
- 使用双指针的经典场景之二: `滑动窗口`
- 双指针的使用技巧之`快慢指针`, 关键是确定两个指针的移动策略

## 链表

- 大多数情况下, 我们使用头节点来表示整个链表
- 单链表插入节点常规 3 步:
    1. 创建新节点
    2. 新节点的指针指向当前节点的下一个节点
    3. 当前节点的指针指向新节点
- 双链表插入常规 3 步:
    1. 创建新节点
    2. 新节点的`prev`和`next`分别指向原链的两个节点
    3. 原链的两个节点的`prev`和`next`分别指向新节点
- 单链表删除节点常规 2 步:
    1. 找出当前节点的前后节点
    2. 当前节点的前一个节点的指针指向当前节点的后一个节点
- `双指针`在链表中大有用处:
    1. 判断链表中是否有环 (如果有环, 快指针会与慢指针相遇)
    2. 判断链表中环的入口 (在快慢指针相遇后, 慢指针继续慢走, 另一个指针从头节点出以相同速度出发, 等他们再次相遇, 即在环入口处)
- 几点注意:
    1. 在调用`next`字段之前, 始终检查节点是否为空
    2. 仔细定义循环的结束条件
    3. 使用链表时, 不易调试, 因此在编码之前, 尝试不同示例验证算法
    4. 使用多指针时, 注意使用适当的名称
    5. 单链表无法追溯前一个节点, 此时存储前一个节点会很有用
    6. 单链表, 由于无法获取给定节点的前继节点, 在删除节点之前, 需要花费 O(n) 的时间找到前继节点
- 经典问题:
    1. 反转链表, 一定要会

## 哈希表

- 哈希表, 通过哈希函数来组织数据, 支持快速插入和搜索.
- 哈希表的关键思想是使用哈希函数`将键映射到存储桶`; 搜索时, 通过哈希函数解析键, 并仅在特定存储桶中搜索.
- 哈希表快速删除的技巧:
    1. 用存储桶中的最后一个元素交换要移除的元素, 然后删除最后一个元素
    2. 使用链表表示存储桶
- 如果每个桶中有太多的值, 这些值将被保留在一个高度平衡的二叉搜索树中
- 哈希集(set)的重要用途是: `判重`
- hashmap 的应用场景之一: `建立密钥和信息之间的映射关系`, 此时需要的不仅是 value 还包括 key, 我觉得一个重要的场景是`argmax`: `sorted(d, key=d.get)`
- hashmap 的应用场景之二: `按键聚合所有信息`, 关键是`遇到现有键时确定策略`, 比较典型的应用是计数器
- `设计键`, 即通过设计一个合适的键来满足某种分类需求, 此时要保证:
    1. 属于同一组的所有值都将映射到同一组中。
    2. 需要分成不同组的值不会映射到同一组。
- 设计键的经验之谈:
    1. 当元素顺序不重要时, 可以使用`排序后的字符串/数组`作为键
    2. 如果只关心每个值的偏移量, 则可以使用`偏移量`作为键, 通常相对第一个值而言
    3. 对于树, 使用`子树的序列化表述`会比`TreeNode`更适合作为键
    4. 在矩阵中, 可以使用`行列索引`作为键, 有时, 键也可以是`同一对角线`
    5. 在数独中, 使用`行列索引的组合`作为键来标识块.

## 二叉树

- 当删除树中的节点时, 删除过程按照后续遍历的顺序进行, 即首先删除左右节点, 然后删除节点本身
- 树的广度优先遍历, 就是层面遍历
- 树的特性之一是: 递归, 因此, **递归是解决树的相关问题的最有效和最常用方法之一**
    - 要点: 对于每个递归层级, 我们只能关注单个节点内的问题, 并通过递归调用函数解决其子节点问题
- 自顶向下地遍历树, 可以看作是一种前序遍历
- 自底向上地遍历树, 可以看作是一种后续遍历

## 二叉搜索树

- 定义:
    1. 每个节点中的值必须大于（或等于）存储在其`左子树`中的任何值。
    2. 每个节点中的值必须小于（或等于）存储在其`右子树`中的任何值。
- 通常来说，对于二叉搜索树，我们可以通过`中序遍历`得到一个`递增的有序序列`。中序遍历是二叉搜索树最常用的遍历方法
- 二叉搜索树中删除节点:
    1. 如果目标节点没有子节点，我们可以直接移除该目标节点。
    2. 如果目标节只有一个子节点，我们可以用其子节点作为替换。
    3. 如果目标节点有两个子节点，我们需要用其中序后继节点或者前驱节点来替换，再删除该目标节点。
- 树结构中的常见用语:
    - 节点的深度 - 从树的根节点到该节点的边数
    - 节点的高度 - 根节点和叶子之间最长路径上的边数
    - 树的高度 - 其根节点的高度
- 一个 N 节点的平衡二叉搜索树, 其高度为`logN`. 平衡二叉树的每个节点的两个子树的深度不会相差超过 1.
- 在二叉搜索树上执行搜索, 插入, 删除, 时间复杂度是`O(高度)`
- 高度平衡的二叉搜索树举例:
    1. 红黑树
    2. AVL树
    3. 伸展树
    4. 树堆
- 哈希集和树集的本质区别在于树集中的键是`有序的`. 树集由高度平衡的二叉搜索树实现